<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>移动端</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <!--禁止ios上自动识别电话-->
  <meta content="telephone=no" name="format-detection" />
  <!--禁止android上自动识别邮箱-->
  <meta content="email=no" name="format-detection" />
  <!--针对ios上的safari上地址栏和顶端样式条-->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <!-- 听说在ios7以上版本就没效果了 -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <!-- 可选default、black、black-translucent 但是我都是用black-->
  <script type="text/javascript">
    var jap = {
      siteId : 'JA2018_2131241', //站点编号，必传字段，如无需要从子午线申请
      autoLogPv: true  //是否自动上报pv
    };
  </script>
  <script>
    ;(function(win, lib) {
      var doc = win.document;
      var docEl = doc.documentElement;
      var metaEl = doc.querySelector('meta[name="viewport"]');
      var flexibleEl = doc.querySelector('meta[name="flexible"]');
      var dpr = 0;
      var scale = 0;
      var tid;
      var flexible = lib.flexible || (lib.flexible = {});

      if (metaEl) {
        var match = metaEl.getAttribute('content').match(/initial\-scale=([\d\.]+)/);
        if (match) {
          scale = parseFloat(match[1]);
          dpr = parseInt(1 / scale);
        }
      } else if (flexibleEl) {
        var content = flexibleEl.getAttribute('content');
        if (content) {
          var initialDpr = content.match(/initial\-dpr=([\d\.]+)/);
          var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/);
          if (initialDpr) {
            dpr = parseFloat(initialDpr[1]);
            scale = parseFloat((1 / dpr).toFixed(2));
          }
          if (maximumDpr) {
            dpr = parseFloat(maximumDpr[1]);
            scale = parseFloat((1 / dpr).toFixed(2));
          }
        }
      }

      if (!dpr && !scale) {
        var isAndroid = win.navigator.appVersion.match(/android/gi);
        var isIPhone = win.navigator.appVersion.match(/iphone/gi);
        var devicePixelRatio = win.devicePixelRatio;
        if (isIPhone) {
          // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
          if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {
            dpr = 3;
          } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)) {
            dpr = 2;
          } else {
            dpr = 1;
          }
        } else {
          // 其他设备下，仍旧使用1倍的方案
          dpr = 1;
        }
        scale = 1 / dpr;
      }

      docEl.setAttribute('data-dpr', dpr);
      if (!metaEl) {
        metaEl = doc.createElement('meta');
        metaEl.setAttribute('name', 'viewport');
        metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');
        if (docEl.firstElementChild) {
          docEl.firstElementChild.appendChild(metaEl);
        } else {
          var wrap = doc.createElement('div');
          wrap.appendChild(metaEl);
          doc.write(wrap.innerHTML);
        }
      }

      function refreshRem() {
        var width = docEl.getBoundingClientRect().width
        // 适配平板
        if (width / dpr > 750) {
          width = 750 * dpr
        }
        var rem = 100 * (width / 750)
        docEl.style.fontSize = rem + 'px'
        flexible.rem = win.rem = rem;
      }

      win.addEventListener('resize', function() {
        clearTimeout(tid);
        tid = setTimeout(refreshRem, 300);
      }, false);
      win.addEventListener('pageshow', function(e) {
        if (e.persisted) {
          clearTimeout(tid);
          tid = setTimeout(refreshRem, 300);
        }
      }, false);

      if (doc.readyState === 'complete') {
        doc.body.style.fontSize = 12 * dpr + 'px';
      } else {
        doc.addEventListener('DOMContentLoaded', function(e) {
          doc.body.style.fontSize = 12 * dpr + 'px';
        }, false);
      }


      refreshRem();

      flexible.dpr = win.dpr = dpr;
      flexible.refreshRem = refreshRem;
      flexible.rem2px = function(d) {
        var val = parseFloat(d) * this.rem;
        if (typeof d === 'string' && d.match(/rem$/)) {
          val += 'px';
        }
        return val;
      }
      flexible.px2rem = function(d) {
        var val = parseFloat(d) / this.rem;
        if (typeof d === 'string' && d.match(/px$/)) {
          val += 'rem';
        }
        return val;
      }

    })(window, window['lib'] || (window['lib'] = {}));
  </script>
  <style>
    /* 导航栏因为是基于屏幕定位，所以padding要进行单独的计算。env在IOS 11.2中新增的，constant在IOS 11.2 已经被废弃，但是我们要做兼容，所以都要用上。 */
    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      display: block;
      box-sizing: border-box;
      /* 因为header导航栏是基于屏幕进行定位，所以要做单独的padding挤压处理 */
      padding-right: constant(safe-area-inset-right);
      padding-left: constant(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-left: env(safe-area-inset-left);
      overflow: scroll;
      background-color:#2889e8;
    }
    /* body 在横屏底下和竖屏底下一定要做好定位，不然*/
    /* 竖屏底下的查询 */
    @media screen and (orientation: portrait) {
      body {
        /* 防止页面被刘海遮住 */
        padding-top: constant(safe-area-inset-top);
      }
    }
    /* 横屏底下的查询 */
    @media screen and (orientation: landscape) {
      body {
        /* IOS 11支持*/
        padding-right: constant(safe-area-inset-right);
        padding-left: constant(safe-area-inset-left);
        /*IOS 11.2版本版本支持*/
        padding-right: env(safe-area-inset-right);
        padding-left: env(safe-area-inset-left);
      }
    }
  </style>
  <script src="//common.360buyimg.com/pk/js/jquery-1.11.3.min.js"></script>
</head>
<body>
<div id="app">
</div>
<script>

</script>
<script>
  window.htmlConfig={
    readOnly:false
  }
</script>
</body>

</html>
